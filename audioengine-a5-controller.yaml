
substitutions:
  IR_ADDRESS:  "0xfd00"
  # IR_POWER:    "0x807f"
  # IR_VOL_UP:   "0x906f"
  # IR_VOL_DOWN: "0xe01f"
  IR_MUTE:     "0xfc03"
  IR_PRESET:   "0xba45"
  # The remote's memory probably was erased, these are probably its default values
  # IR_POWER:    "0xfd02"
  # IR_VOL_UP:   "0xf609"
  # IR_VOL_DOWN: "0xf807"
  # # To control the music
  # IR_PLAY:  "0xfe01"
  # IR_PREV:  "0xeb14"
  # IR_NEXT:  "0xea15"

  # Apple remote
  IR_POWER:    "0xdf03"
  IR_VOL_UP:   "0xdf0a"
  IR_VOL_DOWN: "0xdf0c"
  IR_PLAY:    "0xdf05"
  IR_PREV:    "0xdf09"
  IR_NEXT:    "0xdf06"
  IR_RELEASE: "0xdf07"

  # Philips remote
  PH_POWER:    "0x0d"
  PH_VOL_UP:   "0x10"
  PH_VOL_DOWN: "0x11"
  PH_PLAY:    "0x2c"
  PH_PREV:    "0x2b"
  PH_NEXT:    "0x28"

  GPIO_CTRL_ROTARY_A:      "5"
  GPIO_CTRL_ROTARY_B:      "18"
  GPIO_CTRL_ROTARY_BUTTON: "19"
  GPIO_CTRL_IR:            "3"
  GPIO_CTRL_LED:           "23"

  GPIO_A5_ROTARY_A:        "13"
  GPIO_A5_ROTARY_B:        "16"
  GPIO_A5_ROTARY_BUTTON:   "17"
  GPIO_A5_IR:              "27"

esphome:
  name: ${name}
  platform: ESP32
  board: esp32doit-devkit-v1
  on_boot:
    # initial values for outputs (probably not needed, but better be safe)
    - output.turn_off: a5_rotary_a
    - output.turn_off: a5_rotary_b
    - output.turn_off: a5_rotary_button

    # update the state, resetting first in case the speaker is out of sync
    - script.execute: reset_cur_state
    - script.wait:    reset_cur_state
    - lambda:         id(booted) = true;
    - script.execute: update_speaker_state

globals:
  # The current state of the speaker.
  - id: volume_cur
    type: int
    restore_value: on
    initial_value: '0'
  - id: power_cur
    type: bool
    restore_value: on
    initial_value: '1'
  - id: mute_cur
    type: bool
    restore_value: on
    initial_value: '0'

  # Non-persistent variables used in lambdas
  - id: ir_raw_codes
    type: int
    restore_value: no
    initial_value: '0'
  - id: booted        # to ensure that no updates happen until reset_cur_state finishes
    type: bool
    restore_value: no
    initial_value: 'false'

# The number component creates inputs that appear in HA UI, and
# can be changed either from ESP32 or from HA.
number:
  - platform: template
    id: volume_num
    name: ${upper_name} Volume
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 50
    step: 1
    optimistic: on
    initial_value: 20
    on_value:
      - logger.log: "Volume changed, updating"
      - script.execute: update_speaker_state

  - platform: template
    id: preset_volume_num
    name: ${upper_name} Preset Volume
    icon: "mdi:volume-medium"
    min_value: 0
    max_value: 50
    step: 1
    optimistic: on
    restore_value: on
    initial_value: 20


script:
  # This script is called when anyof id(volume_num)/id(power_sw)/id(mute_sw) change. We have a single script
  # for all, so that simultaneous calls are serialized, by setting "mode: queued"
  # (parallel interactions with the speaker make it hard to predict the resulting state).
  #
  # When each execution starts, it is affected only by the value of id(volume_num)/id(power_sw)/id(mute_sw)
  # at __that moment__, later changes are ignored and will be applied by the next execution.
  #
  - id: update_speaker_state
    mode: queued
    then:
    - lambda: |-
        // When multiple updates are queued, it is common that a previous update has already done
        // the job. If so, stop immediately. Also disable while resetting (until reset_cur_state finishes).
        if(!id(booted) ||
           id(reset_cur_state).is_running() ||
           (id(volume_num).state == id(volume_cur) &&
            id(power_sw).state == id(power_cur ) &&
            id(mute_sw ).state == id(mute_cur  )))
          id(update_speaker_state).stop();

      # Handle some interactions between the volume/power/mute controls
    - logger.log:
        format: "Update state: power %d -> %d, mute %d -> %d, volume %d -> %d"
        args: [ "id(power_cur)", "id(power_sw).state", "id(mute_cur)", "id(mute_sw).state", "id(volume_cur)", "(uint)id(volume_num).state" ]
    - lambda: |-
        // When the speaker is in poweroff/mute mode, a VOL_UP/VOL_DOWN command wakes it up (and the command itlsef
        // is ignored). So if volume is changed, we automatically set power=1 & mute=0
        if(id(volume_cur) != id(volume_num).state) {
          if(!id(power_sw).state) id(power_sw).publish_state(1);
          if( id(mute_sw ).state) id(mute_sw ).publish_state(0);
        }

        // Setting power=0 while mute is on: the poweroff command cancels mute (no need to manually unmute),
        // so we unmute ourselves.
        // Note: the opposite (setting mute when power=0), is not allowed by the mute_sw's turn_on_action!
        if(!id(power_sw).state && id(mute_cur))
          id(mute_sw).publish_state(0);

    # Since we cannot read the speaker's state, if it gets out of sync for any reason, we want to be able to recover. For this reason
    # when the speaker is turned on, we reset the current state before applying the update.
    - if:
        condition:
          lambda: 'return !id(power_cur) && id(power_sw).state;'    # only when the speaker is turned on
        then:
        - script.execute: reset_cur_state
        - script.wait:    reset_cur_state

    - logger.log:
        format: "   execute -> power %d -> %d, mute %d -> %d, volume %d -> %d"
        args: [ "id(power_cur)", "id(power_sw).state", "id(mute_cur)", "id(mute_sw).state", "id(volume_cur)", "(uint)id(volume_num).state" ]

    # Do the updates.
    - script.execute: update_led

    # Update 
    - script.execute: update_mute     # mute before volume, because volume changes when muted cause to unmute and then are ignored
    - script.wait:    update_mute
    - script.execute: update_volume   # volume before power, to allow setting volume 1 before power-off
    - script.wait:    update_volume
    - script.execute: update_power    # power last. Note: we don't care about volume changes duing power-on, cause power-on
    - script.wait:    update_power    # is handled by reset_cur_state anyway, when we arrive here we are always powered on!

    - script.wait: update_led   # make sure that the led effect has finished before starting another update

  # Mute ##############################################################
  - id: update_mute
    then:
      if:
        condition:
          lambda: 'return id(mute_cur) != id(mute_sw).state;'
        then:
          - logger.log: "Sending MUTE"
          - remote_transmitter.transmit_nec:
              address: $IR_ADDRESS
              command: $IR_MUTE
          - lambda: id(mute_cur) = id(mute_sw).state;
          - delay: 500ms      # for edge cases (muted -> poweroff)

  # Power ##############################################################
  - id: update_power
    then:
      if:
        condition:
          lambda: 'return id(power_cur) != id(power_sw).state;'
        then:
          - logger.log: "Sending ROTARY BUTTON"
          - output.turn_on: a5_rotary_button
          - delay: 5ms
          - output.turn_off: a5_rotary_button
          - delay: 50ms
          - lambda: id(power_cur) = id(power_sw).state;

  # Volume  ####################################################################
  #
  # Use the rotary encoder interface to communicate the chage to A5 (it's much
  # faster and accurate than IR), simulating a rotary pulse with the
  # corresponding number of steps. After executing, id(volume_cur) will be
  # equal to id(volume_num)'s value at the start of the call.
  #
  - id: update_volume
    then:
    - lambda: |-
        // When the speaker is powered off, we set the real volume to 1 (although volume_cur is left to the configured value, to
        //  be able to track volume changes). This is because we will run reset_cur_state anyway on power on,
        // (which will lower the volume and then raise it again), and it will be smoother if it runs from low volume.
        // Also this prevents a strange A5 A5 beheviour: if we go to poweroff with volume == 0, waking up automatically sets volume = 50!!
        //
        int target_volume = id(power_sw).state ? id(volume_num).state : 1;
        int steps = target_volume - id(volume_cur);
        id(volume_cur) = id(volume_num).state;

        if(steps != 0)    // not really needed, but maybe it's a bit faster to avoid running the script
          id(send_rotary_pulses).execute(steps);

    - script.wait: send_rotary_pulses   # if the script wasn't started this will have no effect

  # Script that generates `steps` rotary pulses. Used by update_speaker_state & reset_cur_state.
  # Each one is a square pulse of 5ms HIGH + 5ms LOW, out of sync by 5ms between
  # a5_rotary_a and a5_rotary_b (which one fires first determines the direction of movement).
  # Maybe we could use PWM for this, but it's simple to do manually and allows for more control.
  - id: send_rotary_pulses
    parameters:
      steps: int
    then:
    - logger.log:
        format: "Sending %d ROTARY PULSES"
        args: [ "steps" ]
    - repeat:           # note: steps cannot be modified, because nested lambdas receive it by value! So we use 'repeat' instead of 'while'
        count: !lambda 'return std::abs(steps);'
        then:
        - lambda: "id( steps > 0 ? a5_rotary_a : a5_rotary_b ).turn_on();"
        - delay: 5ms
        - lambda: "id( steps > 0 ? a5_rotary_b : a5_rotary_a ).turn_on();"
        - delay: 5ms
        - lambda: "id( steps > 0 ? a5_rotary_a : a5_rotary_b ).turn_off();"
        - delay: 5ms
        - lambda: "id( steps > 0 ? a5_rotary_b : a5_rotary_a ).turn_off();"
        - delay: 15ms     # some room to separate the commands, if missing sometimes a few steps are not recorded

  # Script to update the led. It is launched by update_speaker_state and runs in parallel to it
  - id: update_led
    then:
    # create a "blink" effect by first fading the led down to 0, and then fading it up to its correct value
    - light.control:
        id: ctrl_led_light
        state: off
        transition_length: 40ms
    - delay: 40ms
    - light.control:
        id: ctrl_led_light
        state: !lambda "return id(power_sw).state;"
        brightness: !lambda "return 0.1 + 0.9 * (id(mute_sw).state ? 0 : id(volume_num).state) / 50;"
        transition_length: 40ms


  # This script "resets" the speaker state to the following values:
  #   volume_cur = 0, power_cur = true, mute_cur = false
  # __no matter when the intial state of the speaker is__. It's used on restart and also when the speaker
  # is turned on, to make sure that we are on sync with the speaker, before doing the normal updates.
  #
  - id: reset_cur_state
    then:
    - logger.log: reset_cur_state

    # First send a VOL_DOWN and wait 1 sec for the speaker to wakeup/unmute (in case it is in poweroff/mute mode).
    # It is important to wait 1 sec, otherwise the following commands might be ignored.
    - script.execute:
        id: send_rotary_pulses
        steps: -1
    - script.wait: send_rotary_pulses
    - delay: 500ms

    # Then send by sending 50 VOL_DOWN commands, which leads to the volume going down to 0.
    - script.execute:
        id: send_rotary_pulses
        steps: -50
    - script.wait: send_rotary_pulses

    # Now the state is known.
    - lambda: |-
        id(volume_cur) = 0;
        id(power_cur) = true;
        id(mute_cur) = false;

    # Sends a spotify event, delayed so that we can handle double IR commands
  - id: send_spotify_command
    parameters:
      spotify_command: string
    then:
    - delay: 200ms   # wait, to handle long presses
    - lambda: |-
        ESP_LOGD("send_spotify_command", "%s, %d", spotify_command.c_str(), id(ir_raw_codes));

        // the apple remote sends raw events while the button is pressed. If 3 arrive during the 200ms delay
        // we consider this a long press, and do prev_playlist/next_playlist instead of prev/next.
        if(id(ir_raw_codes) >= 3 && spotify_command != "spotify.play_pause")
          spotify_command += "_playlist";

        HomeassistantServiceResponse resp;
        HomeassistantServiceMap data;
        resp.service = "script.call_appdaemon";
        data.key = "method";
        data.value = spotify_command;
        resp.data.push_back(data);
        api::global_api_server->send_homeassistant_service_call(resp);


# Handle the A5's rotary encoder, used to turn the volume up/down
sensor:
  - platform: rotary_encoder
    id: ctrl_rotary
    internal: on
    resolution: 2
    pin_a:
      number: ${GPIO_CTRL_ROTARY_A}
      mode: INPUT_PULLUP
      inverted: True
    pin_b:
      number: ${GPIO_CTRL_ROTARY_B}
      mode: INPUT_PULLUP
      inverted: True
    on_clockwise:
      number.set:
        id: volume_num
        value: !lambda 'return id(volume_num).state + 1;'
    on_anticlockwise:
      number.set:
        id: volume_num
        value: !lambda 'return id(volume_num).state - 1;'


binary_sensor:
  - platform: gpio
    id: ctrl_rotary_button
    pin:
      number: ${GPIO_CTRL_ROTARY_BUTTON}
      mode: INPUT_PULLUP
      inverted: True
    on_multi_click:
    - timing:
        - ON for at most 0.5s
      then:
        # short press, toggle power
        switch.toggle: power_sw
    - timing:
        - ON for at least 0.5s
      then:
        # long press, set volume to the preset
        number.set:
          id: volume_num
          value: !lambda "return id(preset_volume_num).state;"

# The power_sw / mute_sw switches are shown in the HA UI and allow to control
# the speaker.
switch:
  - platform: template
    id: power_sw
    icon: "mdi:power"
    name: ${upper_name} Power
    optimistic: on      # a request to turn on/off directly changes the switch
    on_turn_on:
      - script.execute: update_speaker_state
    on_turn_off:
      - script.execute: update_speaker_state

  - platform: template
    id: mute_sw
    icon: "mdi:volume-off"
    name: ${upper_name} Mute
    turn_on_action:                       # called when someone asks the switch to turn on
      lambda: |-
        if(id(power_cur))             // mute cannot be turned on while power is off
          id(mute_sw).publish_state(1);
    turn_off_action:                      # called when someone asks the switch to turn off
    - lambda: |-
        id(mute_sw).publish_state(0);
    on_turn_on:
    - script.execute: update_speaker_state
    on_turn_off:
    - script.execute: update_speaker_state


  ####################################### DEBUG BUTTONS ################################3
  # - platform: template
  #   name: "debug_send_power"
  #   on_press:
  #     - logger.log: "sending Power"
  #     - remote_transmitter.transmit_nec:
  #         address: $IR_ADDRESS
  #         command: $IR_POWER

  # - platform: template
  #   id: "debug_send_voldown"
  #   name: "debug_send_voldown"
  #   on_press:
  #     - logger.log: "sending voldown"
  #     - remote_transmitter.transmit_nec:
  #         address: $IR_ADDRESS
  #         command: $IR_VOL_DOWN

  # - platform: template
  #   id: "debug_countdown_to_zero"
  #   name: "debug_countdown_to_zero"
  #   on_press:
  #     - logger.log: "sending voldown until zero"
  #     - remote_transmitter.transmit_nec:
  #         address: $IR_ADDRESS
  #         command: $IR_VOL_DOWN
  #         repeat:
  #           times: !lambda "return id(volume_cur) + 2;"
  #           wait_time: 1s
  #     - lambda: 'id(volume_cur) = 0;'
  #     - number.set:
  #         id: volume_num
  #         value: 0

  # - platform: template
  #   id: "debug_send_volup"
  #   name: "debug_send_volup"
  #   on_press:
  #     - logger.log: "sending volup"
  #     - remote_transmitter.transmit_nec:
  #         address: $IR_ADDRESS
  #         command: $IR_VOL_UP

  # - platform: template
  #   id: "debug_send_mute"
  #   name: "debug_send_mute"
  #   on_press:
  #     - logger.log: "sending mure"
  #     - remote_transmitter.transmit_nec:
  #         address: $IR_ADDRESS
  #         command: $IR_MUTE

  # - platform: template
  #   id: "debug_send_rotary_up"
  #   name: "debug_send_rotary_up"
  #   on_press:
  #     - logger.log: "sending rotary up"
  #     - output.turn_on: a5_rotary_a
  #     - delay: 5ms
  #     - output.turn_on: a5_rotary_b
  #     - delay: 5ms
  #     - output.turn_off: a5_rotary_a
  #     - delay: 5ms
  #     - output.turn_off: a5_rotary_b
  #     - delay: 15ms
  # 
  # - platform: template
  #   id: "debug_send_rotary_down"
  #   name: "debug_send_rotary_down"
  #   on_press:
  #     - logger.log: "sending rotary down"
  #     - output.turn_on: a5_rotary_b
  #     - delay: 5ms
  #     - output.turn_on: a5_rotary_a
  #     - delay: 5ms
  #     - output.turn_off: a5_rotary_b
  #     - delay: 5ms
  #     - output.turn_off: a5_rotary_a
  #     - delay: 15ms
  # 
  # - platform: template
  #   id: "debug_send_rotary_button"
  #   name: "debug_send_rotary_button"
  #   on_press:
  #     - logger.log: "pressing rotary button"
  #     - output.turn_on: a5_rotary_button
  #     - delay: 5ms
  #     - output.turn_off: a5_rotary_button
  # 
  # - platform: template
  #   id: "debug_reset_state"
  #   name: "debug_reset_state"
  #   on_press:
  #     - script.execute: reset_cur_state
  #     - script.wait: reset_cur_state
  #     - script.execute: update_speaker_state
########################################################################################


remote_transmitter:
  # This is our way of communicating with A5 via "simulated" IR, sent directly to the pin
  # where the A5's receiver is normlly connected.
  - id: a5_ir
    carrier_duty_percent: 100%    # No IR 38KHz modultion, just send the real (slow) signal to the A5's receiver
    pin:
      number: ${GPIO_A5_IR}
      inverted: true
      mode: OUTPUT_OPEN_DRAIN     # A5 uses a pullup on its input


output:
  - platform: ledc
    id: ctrl_led
    pin: ${GPIO_CTRL_LED}

  # The following outputs go to the speaker's MCU
  - platform: gpio
    id: a5_rotary_a
    pin:
      number: ${GPIO_A5_ROTARY_A}
      inverted: true
      mode: OUTPUT_OPEN_DRAIN     # A5 uses a pullup on its input

  - platform: gpio
    id: a5_rotary_b
    pin:
      number: ${GPIO_A5_ROTARY_B}
      inverted: true
      mode: OUTPUT_OPEN_DRAIN     # A5 uses a pullup on its input

  - platform: gpio
    id: a5_rotary_button
    pin:
      number: ${GPIO_A5_ROTARY_BUTTON}
      inverted: true
      mode: OUTPUT_OPEN_DRAIN     # A5 uses a pullup on its input


light:
  - platform: monochromatic
    id: ctrl_led_light
    output: ctrl_led
    default_transition_length: 0s


# Handle the A5's IR receiver. The 4 commands (Up/Down/Power/Mute) of the A5's original
# remote are supported, but we can easily add more commands, eg a command that sets
# volume to some preset, or even use the IR receiver to trigger any Home Assistant automation.
remote_receiver:
  id: ctrl_ir
  pin:
    number: ${GPIO_CTRL_IR}
    inverted: true
  # dump: [nec]
  dump: [nec, rc6]
  on_nec:
    lambda: |-
      ESP_LOGD("on_nec", "Got Nec IR, command %x", x.command);

      // Recreate the original remote's commands
      if(x.command == $IR_VOL_UP)
        id(volume_num).make_call().set_value( id(volume_num).state + 1 ).perform();
      else if(x.command == $IR_VOL_DOWN)
        id(volume_num).make_call().set_value( id(volume_num).state - 1 ).perform();
      else if(x.command == $IR_POWER)
        id(power_sw).toggle();
      else if(x.command == $IR_MUTE)
        id(mute_sw).toggle();
      
      // custom command to set a preset volume
      else if(x.command == $IR_PRESET)
        id(volume_num).make_call().set_value( id(preset_volume_num).state ).perform();

      // control music.
      else if(x.command == $IR_PLAY || x.command == $IR_NEXT || x.command == $IR_PREV) {
        std::string spotify_command = "spotify.";
        spotify_command += x.command == $IR_PLAY ? "play_pause" : x.command == $IR_NEXT ? "next" : "previous";
        id(ir_raw_codes) = 0;

        id(send_spotify_command).execute(spotify_command);

        id(update_led).execute();   // blink the led to show that the command ran
      }
  on_raw:
    lambda: id(ir_raw_codes)++;   // just count, see the send_spotify_command script
  on_rc6: # philips remote
    lambda: |-
      ESP_LOGD("on_rc6", "Got Philips IR, command %x", x.command);

      // Recreate the original remote's commands
      if(x.command == $PH_VOL_UP)
        id(volume_num).make_call().set_value( id(volume_num).state + 1 ).perform();
      else if(x.command == $PH_VOL_DOWN)
        id(volume_num).make_call().set_value( id(volume_num).state - 1 ).perform();
      else if(x.command == $PH_POWER)
        id(power_sw).toggle();

      // control music.
      else if(x.command == $PH_PLAY || x.command == $PH_NEXT || x.command == $PH_PREV) {
        if(id(send_spotify_command).is_running()) {
          // Note: the Apple remote sends raw commands while pressing the button, the Philips remote repeats the same command.
          // So we increase the count if the script is already running (see the send_spotify_command script).
          id(ir_raw_codes)++;
        } else {
          std::string spotify_command = "spotify.";
          spotify_command += x.command == $PH_PLAY ? "play_pause" : x.command == $PH_NEXT ? "next" : "previous";
          id(ir_raw_codes) = 0;

          id(send_spotify_command).execute(spotify_command);

          id(update_led).execute();   // blink the led to show that the command ran
        }
      }



# Notes #################################################################################3
#
# esp32doit-devkit-v1 pins: https://www.mischianti.org/wp-content/uploads/2020/11/ESP32-DOIT-DEV-KIT-v1-pinout-mischianti.png
# GPIO02: onboard led
#
# IR codes from http://www.hifi-remote.com/forums/viewtopic.php?t=15739
#
# OBC 1 = Power
# 0000 006C 0000 0022 015B 00AD 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0622
# Code value     0xbf807f
# 
# OBC 3 = Mute
# 0000 006C 0000 0022 015B 00AD 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0622
# Code value     0xbfc03f
# 
# OBC 7 = Vol-
# 0000 006C 0000 0022 015B 00AD 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0622
# Code value     0xbfe01f
# 
# OBC 9 = Vol+
# 0000 006C 0000 0022 015B 00AD 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0041 0016 0016 0016 0016 0016 0041 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0016 0041 0016 0041 0016 0016 0016 0041 0016 0041 0016 0041 0016 0041 0016 0622
# Code value     0xbf906f
# 
# To get the address and command from the raw hex use the gc_decode tool from https://github.com/crankyoldgit/IRremoteESP8266
# Eg:
# ./gc_decode -prontohex "0000 006C ..."
# get output: Code value     0xbf807f 
# use values =>
#    address: 0x00BF
#    command: 0x807F

